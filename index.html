<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>TraceMaster Studio</title>
  <style>
    :root {
      --bg: #0e0e11;
      --fg: #f0f0f0;
      --accent: #58a6ff;
      --toolbar-bg: rgba(30,30,30,0.85);
      --panel-bg: rgba(20,20,20,0.95);
      --border: rgba(255,255,255,0.1);
      --muted: #999;
    }
    body {
      margin: 0;
      background: var(--bg);
      color: var(--fg);
      font-family: system-ui, sans-serif;
      overflow: hidden;
      touch-action: none;
    }
    canvas {
      position: fixed;
      inset: 0;
      cursor: crosshair;
      touch-action: none;
    }
    #toolbar, #settingsPanel {
      position: fixed;
      z-index: 50;
      background: var(--toolbar-bg);
      border: 1px solid var(--border);
      border-radius: 12px;
      backdrop-filter: blur(10px);
      padding: 10px;
      color: var(--fg);
    }
    #toolbar { top: 10px; left: 10px; display: flex; flex-wrap: wrap; gap: 8px; align-items: center; }
    #settingsPanel { top: 10px; right: 10px; width: 260px; display: none; flex-direction: column; }
    button, select, input[type=color], input[type=range] {
      background: var(--panel-bg);
      color: var(--fg);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 6px 10px;
      font-weight: 600;
    }
    button:hover, select:hover { background: rgba(255,255,255,0.1); }
    .section { margin-top: 8px; }
    .toolGroup { display: flex; gap: 4px; flex-wrap: wrap; }
  </style>
</head>
<body>
  <canvas id="draw"></canvas>
  <canvas id="overlay"></canvas>

  <div id="toolbar">
    <button id="uploadBtn">Upload</button>
    <input id="fileInput" type="file" accept="image/*" hidden>
    <button id="pasteBtn">Paste</button>
    <button id="clearBtn">Clear</button>
    <button id="saveBtn">Save PNG</button>
    <select id="toolSelect">
      <option value="brush">Brush</option>
      <option value="eraser">Eraser</option>
      <option value="line">Line</option>
      <option value="rect">Rectangle</option>
      <option value="circle">Circle</option>
      <option value="text">Text</option>
      <option value="fill">Fill</option>
    </select>
    <button id="settingsBtn">⚙️</button>
  </div>

  <div id="settingsPanel">
    <h3>Settings</h3>
    <div class="section">
      <label>Brush Color <input type="color" id="colorPicker" value="#ffffff"></label>
    </div>
    <div class="section">
      <label>Brush Size <input type="range" id="sizePicker" min="1" max="50" value="5"></label>
    </div>
    <div class="section">
      <label>Opacity <input type="range" id="opacityPicker" min="0.1" max="1" step="0.1" value="1"></label>
    </div>
    <div class="section">
      <label>Theme
        <select id="themePicker">
          <option value="dark">Dark</option>
          <option value="light">Light</option>
          <option value="blue">Blue</option>
          <option value="sand">Sand</option>
          <option value="mint">Mint</option>
        </select>
      </label>
    </div>
    <div class="section">
      <button id="gridBtn">Toggle Grid</button>
      <button id="valuesBtn">Greyscale View</button>
    </div>
    <div class="section">
      <button id="undoBtn">Undo</button>
      <button id="redoBtn">Redo</button>
      <button id="resetBtn">Reset Canvas</button>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('draw');
    const ctx = canvas.getContext('2d');
    const overlay = document.getElementById('overlay');
    const octx = overlay.getContext('2d');

    let drawing = false;
    let startX, startY;
    let tool = 'brush';
    let brushColor = '#ffffff';
    let brushSize = 5;
    let brushOpacity = 1;
    let img = null;

    const resize = () => {
      canvas.width = overlay.width = window.innerWidth;
      canvas.height = overlay.height = window.innerHeight;
      if (img) ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
    };
    window.addEventListener('resize', resize);
    resize();

    document.getElementById('toolSelect').onchange = e => tool = e.target.value;
    document.getElementById('colorPicker').onchange = e => brushColor = e.target.value;
    document.getElementById('sizePicker').oninput = e => brushSize = +e.target.value;
    document.getElementById('opacityPicker').oninput = e => brushOpacity = +e.target.value;

    overlay.addEventListener('pointerdown', e => {
      drawing = true;
      startX = e.clientX; startY = e.clientY;
      if (tool === 'fill') {
        ctx.fillStyle = brushColor;
        ctx.fillRect(0,0,canvas.width,canvas.height);
      }
    });
    overlay.addEventListener('pointerup', e => {
      if (!drawing) return;
      drawing = false;
      if (tool === 'line' || tool === 'rect' || tool === 'circle') {
        ctx.globalAlpha = brushOpacity;
        ctx.strokeStyle = brushColor;
        ctx.lineWidth = brushSize;
        const w = e.clientX - startX;
        const h = e.clientY - startY;
        if (tool === 'line') {
          ctx.beginPath(); ctx.moveTo(startX, startY); ctx.lineTo(e.clientX, e.clientY); ctx.stroke();
        } else if (tool === 'rect') {
          ctx.strokeRect(startX, startY, w, h);
        } else if (tool === 'circle') {
          ctx.beginPath();
          const r = Math.sqrt(w*w+h*h);
          ctx.arc(startX, startY, r, 0, Math.PI*2);
          ctx.stroke();
        }
        octx.clearRect(0,0,overlay.width,overlay.height);
      }
    });
    overlay.addEventListener('pointermove', e => {
      if (!drawing) return;
      if (tool === 'brush' || tool === 'eraser') {
        ctx.globalAlpha = brushOpacity;
        ctx.lineWidth = brushSize;
        ctx.lineCap = 'round';
        ctx.strokeStyle = tool === 'eraser' ? '#000' : brushColor;
        ctx.lineTo(e.clientX, e.clientY);
        ctx.stroke();
      } else if (['line','rect','circle'].includes(tool)) {
        octx.clearRect(0,0,overlay.width,overlay.height);
        octx.strokeStyle = brushColor;
        octx.lineWidth = 1;
        const w = e.clientX - startX;
        const h = e.clientY - startY;
        if (tool === 'line') {
          octx.beginPath(); octx.moveTo(startX,startY); octx.lineTo(e.clientX,e.clientY); octx.stroke();
        } else if (tool === 'rect') {
          octx.strokeRect(startX,startY,w,h);
        } else if (tool === 'circle') {
          octx.beginPath();
          const r = Math.sqrt(w*w+h*h);
          octx.arc(startX,startY,r,0,Math.PI*2);
          octx.stroke();
        }
      }
    });

    document.getElementById('clearBtn').onclick = () => ctx.clearRect(0,0,canvas.width,canvas.height);
    document.getElementById('saveBtn').onclick = () => {
      const link = document.createElement('a');
      link.download = 'trace.png';
      link.href = canvas.toDataURL('image/png');
      link.click();
    };

    document.getElementById('uploadBtn').onclick = ()=> document.getElementById('fileInput').click();
    document.getElementById('fileInput').onchange = e => {
      const file = e.target.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = ev => {
          const image = new Image();
          image.onload = () => {
            img = image;
            ctx.drawImage(image, 0, 0, canvas.width, canvas.height);
          };
          image.src = ev.target.result;
        };
        reader.readAsDataURL(file);
      }
    };

    document.getElementById('settingsBtn').onclick = ()=>{
      const panel = document.getElementById('settingsPanel');
      panel.style.display = panel.style.display==='flex'?'none':'flex';
    };

    document.getElementById('themePicker').onchange = e => {
      const theme = e.target.value;
      if(theme==='light'){
        document.documentElement.style.setProperty('--bg','#f5f5f7');
        document.documentElement.style.setProperty('--fg','#0b0b0c');
        document.documentElement.style.setProperty('--toolbar-bg','rgba(255,255,255,0.8)');
      } else if(theme==='blue'){
        document.documentElement.style.setProperty('--bg','#001f3f');
        document.documentElement.style.setProperty('--fg','#f5f5f7');
      } else if(theme==='sand'){
        document.documentElement.style.setProperty('--bg','#f3efe6');
        document.documentElement.style.setProperty('--fg','#2b2b2b');
      } else if(theme==='mint'){
        document.documentElement.style.setProperty('--bg','#e9fff9');
        document.documentElement.style.setProperty('--fg','#202020');
      } else {
        document.documentElement.style.setProperty('--bg','#0e0e11');
        document.documentElement.style.setProperty('--fg','#f0f0f0');
      }
    };

    document.getElementById('gridBtn').onclick = ()=>{
      const show = !overlay.classList.contains('grid');
      overlay.classList.toggle('grid',show);
      if(show){
        const step=50; octx.strokeStyle='rgba(255,255,255,0.1)';
        for(let x=0;x<overlay.width;x+=step){ octx.beginPath(); octx.moveTo(x,0); octx.lineTo(x,overlay.height); octx.stroke(); }
        for(let y=0;y<overlay.height;y+=step){ octx.beginPath(); octx.moveTo(0,y); octx.lineTo(overlay.width,y); octx.stroke(); }
      } else {
        octx.clearRect(0,0,overlay.width,overlay.height);
      }
    };

    document.getElementById('valuesBtn').onclick = ()=>{
      document.body.classList.toggle('greyscale');
      if(document.body.classList.contains('greyscale')){
        canvas.style.filter='grayscale(100%)';
      } else canvas.style.filter='none';
    };
  </script>
</body>
</html>
